import BlogModel, { IBlog } from "../../database/models/blog.model";
import {
  CreateBlogInput,
  UpdateBlogInput,
} from "../../lib/validation/blog.validation";
import { NotFoundException } from "../../lib/errors/catch-errors";

export class BlogService {
  public async createBlog(
    authorId: string,
    input: CreateBlogInput
  ): Promise<IBlog> {
    const blog = new BlogModel({
      ...input,
      author: authorId,
      publishedAt: input.isPublished ? new Date() : undefined,
    });
    await blog.save();
    return blog;
  }

  public async getAllBlogs(
    page: number = 1,
    limit: number = 10,
    isPublished?: boolean,
    q?: string
  ) {
    const skip = (page - 1) * limit;
    const filter: { isPublished?: boolean; $or?: any[] } = {};

    if (q) {
      filter.$or = [
        { title: { $regex: q, $options: "i" } },
        { excerpt: { $regex: q, $options: "i" } },
        { tags: { $elemMatch: { $regex: q, $options: "i" } } },
        { contentHtml: { $regex: q, $options: "i" } },
      ];
    }

    if (isPublished !== undefined) {
      filter.isPublished = isPublished;
    }

    const blogs = await BlogModel.find(filter)
      .populate("author", "name email")
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const total = await BlogModel.countDocuments(filter);

    return {
      blogs,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };
  }

  public async getBlogBySlug(slug: string): Promise<IBlog> {
    const blog = await BlogModel.findOne({ slug }).populate(
      "author",
      "name email"
    );
    if (!blog) {
      throw new NotFoundException("Blog post not found");
    }
    return blog;
  }

  public async updateBlog(
    blogId: string,
    input: UpdateBlogInput
  ): Promise<IBlog> {
    const blog = await BlogModel.findById(blogId);

    if (!blog) {
      throw new NotFoundException("Blog post not found");
    }

    // If the title is being updated, the slug will be regenerated by the pre-save middleware
    Object.assign(blog, input);

    // Handle publishing state change
    if (input.isPublished && !blog.publishedAt) {
      blog.publishedAt = new Date();
    } else if (input.isPublished === false) {
      blog.publishedAt = undefined;
    }

    await blog.save();
    return blog;
  }

  public async deleteBlog(blogId: string): Promise<{ message: string }> {
    const result = await BlogModel.findByIdAndDelete(blogId);
    if (!result) {
      throw new NotFoundException("Blog post not found");
    }
    return { message: "Blog post deleted successfully" };
  }
}
